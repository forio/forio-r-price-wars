this.org = this.org || {}, org.cometd = {}, org.cometd.JSON = {}, org.cometd.JSON.toJSON = org.cometd.JSON.fromJSON = function() {
    throw "Abstract";
}, org.cometd.Utils = {}, org.cometd.Utils.isString = function(value) {
    return void 0 === value || null === value ? !1 : "string" == typeof value || value instanceof String;
}, org.cometd.Utils.isArray = function(value) {
    return void 0 === value || null === value ? !1 : value instanceof Array;
}, org.cometd.Utils.inArray = function(element, array) {
    for (var i = 0; i < array.length; ++i) if (element === array[i]) return i;
    return -1;
}, org.cometd.Utils.setTimeout = function(cometd, funktion, delay) {
    return window.setTimeout(function() {
        try {
            funktion();
        } catch (x) {
            cometd._debug("Exception invoking timed function", funktion, x);
        }
    }, delay);
}, org.cometd.Utils.clearTimeout = function(timeoutHandle) {
    window.clearTimeout(timeoutHandle);
}, org.cometd.TransportRegistry = function() {
    var _types = [], _transports = {};
    this.getTransportTypes = function() {
        return _types.slice(0);
    }, this.findTransportTypes = function(version, crossDomain, url) {
        for (var result = [], i = 0; i < _types.length; ++i) {
            var type = _types[i];
            _transports[type].accept(version, crossDomain, url) === !0 && result.push(type);
        }
        return result;
    }, this.negotiateTransport = function(types, version, crossDomain, url) {
        for (var i = 0; i < _types.length; ++i) for (var type = _types[i], j = 0; j < types.length; ++j) if (type === types[j]) {
            var transport = _transports[type];
            if (transport.accept(version, crossDomain, url) === !0) return transport;
        }
        return null;
    }, this.add = function(type, transport, index) {
        for (var existing = !1, i = 0; i < _types.length; ++i) if (_types[i] === type) {
            existing = !0;
            break;
        }
        return existing || ("number" != typeof index ? _types.push(type) : _types.splice(index, 0, type), 
        _transports[type] = transport), !existing;
    }, this.find = function(type) {
        for (var i = 0; i < _types.length; ++i) if (_types[i] === type) return _transports[type];
        return null;
    }, this.remove = function(type) {
        for (var i = 0; i < _types.length; ++i) if (_types[i] === type) {
            _types.splice(i, 1);
            var transport = _transports[type];
            return delete _transports[type], transport;
        }
        return null;
    }, this.clear = function() {
        _types = [], _transports = {};
    }, this.reset = function() {
        for (var i = 0; i < _types.length; ++i) _transports[_types[i]].reset();
    };
}, org.cometd.Transport = function() {
    var _type, _cometd;
    this.registered = function(type, cometd) {
        _type = type, _cometd = cometd;
    }, this.unregistered = function() {
        _type = null, _cometd = null;
    }, this._debug = function() {
        _cometd._debug.apply(_cometd, arguments);
    }, this._mixin = function() {
        return _cometd._mixin.apply(_cometd, arguments);
    }, this.getConfiguration = function() {
        return _cometd.getConfiguration();
    }, this.getAdvice = function() {
        return _cometd.getAdvice();
    }, this.setTimeout = function(funktion, delay) {
        return org.cometd.Utils.setTimeout(_cometd, funktion, delay);
    }, this.clearTimeout = function(handle) {
        org.cometd.Utils.clearTimeout(handle);
    }, this.convertToMessages = function(response) {
        if (org.cometd.Utils.isString(response)) try {
            return org.cometd.JSON.fromJSON(response);
        } catch (x) {
            throw this._debug("Could not convert to JSON the following string", '"' + response + '"'), 
            x;
        }
        if (org.cometd.Utils.isArray(response)) return response;
        if (void 0 === response || null === response) return [];
        if (response instanceof Object) return [ response ];
        throw "Conversion Error " + response + ", typeof " + typeof response;
    }, this.accept = function() {
        throw "Abstract";
    }, this.getType = function() {
        return _type;
    }, this.send = function() {
        throw "Abstract";
    }, this.reset = function() {
        this._debug("Transport", _type, "reset");
    }, this.abort = function() {
        this._debug("Transport", _type, "aborted");
    }, this.toString = function() {
        return this.getType();
    };
}, org.cometd.Transport.derive = function(baseObject) {
    function F() {}
    return F.prototype = baseObject, new F();
}, org.cometd.RequestTransport = function() {
    function _coalesceEnvelopes(envelope) {
        for (;_envelopes.length > 0; ) {
            var envelopeAndRequest = _envelopes[0], newEnvelope = envelopeAndRequest[0], newRequest = envelopeAndRequest[1];
            if (newEnvelope.url !== envelope.url || newEnvelope.sync !== envelope.sync) break;
            _envelopes.shift(), envelope.messages = envelope.messages.concat(newEnvelope.messages), 
            this._debug("Coalesced", newEnvelope.messages.length, "messages from request", newRequest.id);
        }
    }
    function _transportSend(envelope, request) {
        if (this.transportSend(envelope, request), request.expired = !1, !envelope.sync) {
            var maxDelay = this.getConfiguration().maxNetworkDelay, delay = maxDelay;
            request.metaConnect === !0 && (delay += this.getAdvice().timeout), this._debug("Transport", this.getType(), "waiting at most", delay, "ms for the response, maxNetworkDelay", maxDelay);
            var self = this;
            request.timeout = this.setTimeout(function() {
                request.expired = !0;
                var errorMessage = "Request " + request.id + " of transport " + self.getType() + " exceeded " + delay + " ms max network delay", failure = {
                    reason: errorMessage
                }, xhr = request.xhr;
                failure.httpCode = self.xhrStatus(xhr), self.abortXHR(xhr), self._debug(errorMessage), 
                self.complete(request, !1, request.metaConnect), envelope.onFailure(xhr, envelope.messages, failure);
            }, delay);
        }
    }
    function _queueSend(envelope) {
        var requestId = ++_requestIds, request = {
            id: requestId,
            metaConnect: !1
        };
        _requests.length < this.getConfiguration().maxConnections - 1 ? (_requests.push(request), 
        _transportSend.call(this, envelope, request)) : (this._debug("Transport", this.getType(), "queueing request", requestId, "envelope", envelope), 
        _envelopes.push([ envelope, request ]));
    }
    function _metaConnectComplete(request) {
        var requestId = request.id;
        if (this._debug("Transport", this.getType(), "metaConnect complete, request", requestId), 
        null !== _metaConnectRequest && _metaConnectRequest.id !== requestId) throw "Longpoll request mismatch, completing request " + requestId;
        _metaConnectRequest = null;
    }
    function _complete(request, success) {
        var index = org.cometd.Utils.inArray(request, _requests);
        if (index >= 0 && _requests.splice(index, 1), _envelopes.length > 0) {
            var envelopeAndRequest = _envelopes.shift(), nextEnvelope = envelopeAndRequest[0], nextRequest = envelopeAndRequest[1];
            if (this._debug("Transport dequeued request", nextRequest.id), success) this.getConfiguration().autoBatch && _coalesceEnvelopes.call(this, nextEnvelope), 
            _queueSend.call(this, nextEnvelope), this._debug("Transport completed request", request.id, nextEnvelope); else {
                var self = this;
                this.setTimeout(function() {
                    self.complete(nextRequest, !1, nextRequest.metaConnect);
                    var failure = {
                        reason: "Previous request failed"
                    }, xhr = nextRequest.xhr;
                    failure.httpCode = self.xhrStatus(xhr), nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);
                }, 0);
            }
        }
    }
    function _metaConnectSend(envelope) {
        if (null !== _metaConnectRequest) throw "Concurrent metaConnect requests not allowed, request id=" + _metaConnectRequest.id + " not yet completed";
        var requestId = ++_requestIds;
        this._debug("Transport", this.getType(), "metaConnect send, request", requestId, "envelope", envelope);
        var request = {
            id: requestId,
            metaConnect: !0
        };
        _transportSend.call(this, envelope, request), _metaConnectRequest = request;
    }
    var _super = new org.cometd.Transport(), _self = org.cometd.Transport.derive(_super), _requestIds = 0, _metaConnectRequest = null, _requests = [], _envelopes = [];
    return _self.complete = function(request, success, metaConnect) {
        metaConnect ? _metaConnectComplete.call(this, request) : _complete.call(this, request, success);
    }, _self.transportSend = function() {
        throw "Abstract";
    }, _self.transportSuccess = function(envelope, request, responses) {
        request.expired || (this.clearTimeout(request.timeout), this.complete(request, !0, request.metaConnect), 
        responses && responses.length > 0 ? envelope.onSuccess(responses) : envelope.onFailure(request.xhr, envelope.messages, {
            httpCode: 204
        }));
    }, _self.transportFailure = function(envelope, request, failure) {
        request.expired || (this.clearTimeout(request.timeout), this.complete(request, !1, request.metaConnect), 
        envelope.onFailure(request.xhr, envelope.messages, failure));
    }, _self.send = function(envelope, metaConnect) {
        metaConnect ? _metaConnectSend.call(this, envelope) : _queueSend.call(this, envelope);
    }, _self.abort = function() {
        _super.abort();
        for (var i = 0; i < _requests.length; ++i) {
            var request = _requests[i];
            this._debug("Aborting request", request), this.abortXHR(request.xhr);
        }
        _metaConnectRequest && (this._debug("Aborting metaConnect request", _metaConnectRequest), 
        this.abortXHR(_metaConnectRequest.xhr)), this.reset();
    }, _self.reset = function() {
        _super.reset(), _metaConnectRequest = null, _requests = [], _envelopes = [];
    }, _self.abortXHR = function(xhr) {
        if (xhr) try {
            xhr.abort();
        } catch (x) {
            this._debug(x);
        }
    }, _self.xhrStatus = function(xhr) {
        if (xhr) try {
            return xhr.status;
        } catch (x) {
            this._debug(x);
        }
        return -1;
    }, _self;
}, org.cometd.LongPollingTransport = function() {
    var _super = new org.cometd.RequestTransport(), _self = org.cometd.Transport.derive(_super), _supportsCrossDomain = !0;
    return _self.accept = function(version, crossDomain) {
        return _supportsCrossDomain || !crossDomain;
    }, _self.xhrSend = function() {
        throw "Abstract";
    }, _self.transportSend = function(envelope, request) {
        this._debug("Transport", this.getType(), "sending request", request.id, "envelope", envelope);
        var self = this;
        try {
            var sameStack = !0;
            request.xhr = this.xhrSend({
                transport: this,
                url: envelope.url,
                sync: envelope.sync,
                headers: this.getConfiguration().requestHeaders,
                body: org.cometd.JSON.toJSON(envelope.messages),
                onSuccess: function(response) {
                    self._debug("Transport", self.getType(), "received response", response);
                    var success = !1;
                    try {
                        var received = self.convertToMessages(response);
                        0 === received.length ? (_supportsCrossDomain = !1, self.transportFailure(envelope, request, {
                            httpCode: 204
                        })) : (success = !0, self.transportSuccess(envelope, request, received));
                    } catch (x) {
                        if (self._debug(x), !success) {
                            _supportsCrossDomain = !1;
                            var failure = {
                                exception: x
                            };
                            failure.httpCode = self.xhrStatus(request.xhr), self.transportFailure(envelope, request, failure);
                        }
                    }
                },
                onError: function(reason, exception) {
                    _supportsCrossDomain = !1;
                    var failure = {
                        reason: reason,
                        exception: exception
                    };
                    failure.httpCode = self.xhrStatus(request.xhr), sameStack ? self.setTimeout(function() {
                        self.transportFailure(envelope, request, failure);
                    }, 0) : self.transportFailure(envelope, request, failure);
                }
            }), sameStack = !1;
        } catch (x) {
            _supportsCrossDomain = !1, this.setTimeout(function() {
                self.transportFailure(envelope, request, {
                    exception: x
                });
            }, 0);
        }
    }, _self.reset = function() {
        _super.reset(), _supportsCrossDomain = !0;
    }, _self;
}, org.cometd.CallbackPollingTransport = function() {
    var _super = new org.cometd.RequestTransport(), _self = org.cometd.Transport.derive(_super), _maxLength = 2e3;
    return _self.accept = function() {
        return !0;
    }, _self.jsonpSend = function() {
        throw "Abstract";
    }, _self.transportSend = function(envelope, request) {
        for (var self = this, start = 0, length = envelope.messages.length, lengths = []; length > 0; ) {
            var json = org.cometd.JSON.toJSON(envelope.messages.slice(start, start + length)), urlLength = envelope.url.length + encodeURI(json).length;
            if (urlLength > _maxLength) {
                if (1 === length) return void this.setTimeout(function() {
                    self.transportFailure(envelope, request, {
                        reason: "Bayeux message too big, max is " + _maxLength
                    });
                }, 0);
                --length;
            } else lengths.push(length), start += length, length = envelope.messages.length - start;
        }
        var envelopeToSend = envelope;
        if (lengths.length > 1) {
            var begin = 0, end = lengths[0];
            this._debug("Transport", this.getType(), "split", envelope.messages.length, "messages into", lengths.join(" + ")), 
            envelopeToSend = this._mixin(!1, {}, envelope), envelopeToSend.messages = envelope.messages.slice(begin, end), 
            envelopeToSend.onSuccess = envelope.onSuccess, envelopeToSend.onFailure = envelope.onFailure;
            for (var i = 1; i < lengths.length; ++i) {
                var nextEnvelope = this._mixin(!1, {}, envelope);
                begin = end, end += lengths[i], nextEnvelope.messages = envelope.messages.slice(begin, end), 
                nextEnvelope.onSuccess = envelope.onSuccess, nextEnvelope.onFailure = envelope.onFailure, 
                this.send(nextEnvelope, request.metaConnect);
            }
        }
        this._debug("Transport", this.getType(), "sending request", request.id, "envelope", envelopeToSend);
        try {
            var sameStack = !0;
            this.jsonpSend({
                transport: this,
                url: envelopeToSend.url,
                sync: envelopeToSend.sync,
                headers: this.getConfiguration().requestHeaders,
                body: org.cometd.JSON.toJSON(envelopeToSend.messages),
                onSuccess: function(responses) {
                    var success = !1;
                    try {
                        var received = self.convertToMessages(responses);
                        0 === received.length ? self.transportFailure(envelopeToSend, request, {
                            httpCode: 204
                        }) : (success = !0, self.transportSuccess(envelopeToSend, request, received));
                    } catch (x) {
                        self._debug(x), success || self.transportFailure(envelopeToSend, request, {
                            exception: x
                        });
                    }
                },
                onError: function(reason, exception) {
                    var failure = {
                        reason: reason,
                        exception: exception
                    };
                    sameStack ? self.setTimeout(function() {
                        self.transportFailure(envelopeToSend, request, failure);
                    }, 0) : self.transportFailure(envelopeToSend, request, failure);
                }
            }), sameStack = !1;
        } catch (xx) {
            this.setTimeout(function() {
                self.transportFailure(envelopeToSend, request, {
                    exception: xx
                });
            }, 0);
        }
    }, _self;
}, org.cometd.WebSocketTransport = function() {
    function _websocketConnect() {
        if (!_connecting) {
            _connecting = !0;
            var url = _cometd.getURL().replace(/^http/, "ws");
            this._debug("Transport", this.getType(), "connecting to URL", url);
            try {
                var protocol = _cometd.getConfiguration().protocol, webSocket = protocol ? new org.cometd.WebSocket(url, protocol) : new org.cometd.WebSocket(url);
            } catch (x) {
                throw _webSocketSupported = !1, this._debug("Exception while creating WebSocket object", x), 
                x;
            }
            _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== !1;
            var self = this, connectTimer = null, connectTimeout = _cometd.getConfiguration().connectTimeout;
            connectTimeout > 0 && (connectTimer = this.setTimeout(function() {
                connectTimer = null, self._debug("Transport", self.getType(), "timed out while connecting to URL", url, ":", connectTimeout, "ms");
                var event = {
                    code: 1e3,
                    reason: "Connect Timeout"
                };
                self.webSocketClose(webSocket, event.code, event.reason), self.onClose(webSocket, event);
            }, connectTimeout));
            var onopen = function() {
                self._debug("WebSocket opened", webSocket), _connecting = !1, connectTimer && (self.clearTimeout(connectTimer), 
                connectTimer = null), _webSocket ? (_cometd._warn("Closing Extra WebSocket Connections", webSocket, _webSocket), 
                self.webSocketClose(webSocket, 1e3, "Extra Connection")) : self.onOpen(webSocket);
            }, onclose = function(event) {
                event = event || {
                    code: 1e3
                }, self._debug("WebSocket closing", webSocket, event), _connecting = !1, connectTimer && (self.clearTimeout(connectTimer), 
                connectTimer = null), null !== _webSocket && webSocket !== _webSocket ? self._debug("Closed Extra WebSocket Connection", webSocket) : self.onClose(webSocket, event);
            }, onmessage = function(message) {
                self._debug("WebSocket message", message, webSocket), webSocket !== _webSocket && _cometd._warn("Extra WebSocket Connections", webSocket, _webSocket), 
                self.onMessage(webSocket, message);
            };
            webSocket.onopen = onopen, webSocket.onclose = onclose, webSocket.onerror = function() {
                onclose({
                    code: 1002,
                    reason: "Error"
                });
            }, webSocket.onmessage = onmessage, this._debug("Transport", this.getType(), "configured callbacks on", webSocket);
        }
    }
    function _webSocketSend(webSocket, envelope, metaConnect) {
        var json = org.cometd.JSON.toJSON(envelope.messages);
        webSocket.send(json), this._debug("Transport", this.getType(), "sent", envelope, "metaConnect =", metaConnect);
        var maxDelay = this.getConfiguration().maxNetworkDelay, delay = maxDelay;
        metaConnect && (delay += this.getAdvice().timeout, _connected = !0);
        for (var self = this, messageIds = [], i = 0; i < envelope.messages.length; ++i) !function() {
            var message = envelope.messages[i];
            message.id && (messageIds.push(message.id), _timeouts[message.id] = this.setTimeout(function() {
                self._debug("Transport", self.getType(), "timing out message", message.id, "after", delay, "on", webSocket);
                var event = {
                    code: 1e3,
                    reason: "Message Timeout"
                };
                self.webSocketClose(webSocket, event.code, event.reason), self.onClose(webSocket, event);
            }, delay));
        }();
        this._debug("Transport", this.getType(), "waiting at most", delay, "ms for messages", messageIds, "maxNetworkDelay", maxDelay, ", timeouts:", _timeouts);
    }
    function _send(webSocket, envelope, metaConnect) {
        try {
            null === webSocket ? _websocketConnect.call(this) : _webSocketSend.call(this, webSocket, envelope, metaConnect);
        } catch (x) {
            this.setTimeout(function() {
                envelope.onFailure(webSocket, envelope.messages, {
                    exception: x
                });
            }, 0);
        }
    }
    var _cometd, _super = new org.cometd.Transport(), _self = org.cometd.Transport.derive(_super), _webSocketSupported = !0, _webSocketConnected = !1, _stickyReconnect = !0, _envelopes = {}, _timeouts = {}, _connecting = !1, _webSocket = null, _connected = !1, _successCallback = null;
    return _self.reset = function() {
        _super.reset(), _webSocketSupported = !0, _webSocketConnected = !1, _stickyReconnect = !0, 
        _envelopes = {}, _timeouts = {}, _connecting = !1, _webSocket = null, _connected = !1, 
        _successCallback = null;
    }, _self.onOpen = function(webSocket) {
        this._debug("Transport", this.getType(), "opened", webSocket), _webSocket = webSocket, 
        _webSocketConnected = !0, this._debug("Sending pending messages", _envelopes);
        for (var key in _envelopes) {
            var element = _envelopes[key], envelope = element[0], metaConnect = element[1];
            _successCallback = envelope.onSuccess, _webSocketSend.call(this, webSocket, envelope, metaConnect);
        }
    }, _self.onMessage = function(webSocket, wsMessage) {
        this._debug("Transport", this.getType(), "received websocket message", wsMessage, webSocket);
        for (var close = !1, messages = this.convertToMessages(wsMessage.data), messageIds = [], i = 0; i < messages.length; ++i) {
            var message = messages[i];
            if ((/^\/meta\//.test(message.channel) || void 0 !== message.successful) && message.id) {
                messageIds.push(message.id);
                var timeout = _timeouts[message.id];
                timeout && (this.clearTimeout(timeout), delete _timeouts[message.id], this._debug("Transport", this.getType(), "removed timeout for message", message.id, ", timeouts", _timeouts));
            }
            "/meta/connect" === message.channel && (_connected = !1), "/meta/disconnect" !== message.channel || _connected || (close = !0);
        }
        for (var removed = !1, j = 0; j < messageIds.length; ++j) {
            var id = messageIds[j];
            for (var key in _envelopes) {
                var ids = key.split(","), index = org.cometd.Utils.inArray(id, ids);
                if (index >= 0) {
                    removed = !0, ids.splice(index, 1);
                    var envelope = _envelopes[key][0], metaConnect = _envelopes[key][1];
                    delete _envelopes[key], ids.length > 0 && (_envelopes[ids.join(",")] = [ envelope, metaConnect ]);
                    break;
                }
            }
        }
        removed && this._debug("Transport", this.getType(), "removed envelope, envelopes", _envelopes), 
        _successCallback.call(this, messages), close && this.webSocketClose(webSocket, 1e3, "Disconnect");
    }, _self.onClose = function(webSocket, event) {
        this._debug("Transport", this.getType(), "closed", webSocket, event), _webSocketSupported = _stickyReconnect && _webSocketConnected;
        var timeouts = _timeouts;
        _timeouts = {};
        for (var id in timeouts) this.clearTimeout(timeouts[id]);
        var envelopes = _envelopes;
        _envelopes = {};
        for (var key in envelopes) {
            var envelope = envelopes[key][0], metaConnect = envelopes[key][1];
            metaConnect && (_connected = !1), envelope.onFailure(webSocket, envelope.messages, {
                websocketCode: event.code,
                reason: event.reason
            });
        }
        _webSocket = null;
    }, _self.registered = function(type, cometd) {
        _super.registered(type, cometd), _cometd = cometd;
    }, _self.accept = function() {
        return _webSocketSupported && !!org.cometd.WebSocket && _cometd.websocketEnabled !== !1;
    }, _self.send = function(envelope, metaConnect) {
        this._debug("Transport", this.getType(), "sending", envelope, "metaConnect =", metaConnect);
        for (var messageIds = [], i = 0; i < envelope.messages.length; ++i) {
            var message = envelope.messages[i];
            message.id && messageIds.push(message.id);
        }
        _envelopes[messageIds.join(",")] = [ envelope, metaConnect ], this._debug("Transport", this.getType(), "stored envelope, envelopes", _envelopes), 
        _send.call(this, _webSocket, envelope, metaConnect);
    }, _self.webSocketClose = function(webSocket, code, reason) {
        try {
            webSocket.close(code, reason);
        } catch (x) {
            this._debug(x);
        }
    }, _self.abort = function() {
        if (_super.abort(), _webSocket) {
            var event = {
                code: 1001,
                reason: "Abort"
            };
            this.webSocketClose(_webSocket, event.code, event.reason), this.onClose(_webSocket, event);
        }
        this.reset();
    }, _self;
}, org.cometd.Cometd = function(name) {
    function _fieldValue(object, name) {
        try {
            return object[name];
        } catch (x) {
            return void 0;
        }
    }
    function _isString(value) {
        return org.cometd.Utils.isString(value);
    }
    function _isFunction(value) {
        return void 0 === value || null === value ? !1 : "function" == typeof value;
    }
    function _log(level, args) {
        if (window.console) {
            var logger = window.console[level];
            _isFunction(logger) && logger.apply(window.console, args);
        }
    }
    function _configure(configuration) {
        _cometd._debug("Configuring cometd object with", configuration), _isString(configuration) && (configuration = {
            url: configuration
        }), configuration || (configuration = {}), _config = _cometd._mixin(!1, _config, configuration);
        var url = _cometd.getURL();
        if (!url) throw "Missing required configuration parameter 'url' specifying the Bayeux server URL";
        var urlParts = /(^https?:\/\/)?(((\[[^\]]+\])|([^:\/\?#]+))(:(\d+))?)?([^\?#]*)(.*)?/.exec(url), hostAndPort = urlParts[2], uri = urlParts[8], afterURI = urlParts[9];
        if (_crossDomain = _cometd._isCrossDomain(hostAndPort), _config.appendMessageTypeToURL) if (void 0 !== afterURI && afterURI.length > 0) _cometd._info("Appending message type to URI " + uri + afterURI + " is not supported, disabling 'appendMessageTypeToURL' configuration"), 
        _config.appendMessageTypeToURL = !1; else {
            var uriSegments = uri.split("/"), lastSegmentIndex = uriSegments.length - 1;
            uri.match(/\/$/) && (lastSegmentIndex -= 1), uriSegments[lastSegmentIndex].indexOf(".") >= 0 && (_cometd._info("Appending message type to URI " + uri + " is not supported, disabling 'appendMessageTypeToURL' configuration"), 
            _config.appendMessageTypeToURL = !1);
        }
    }
    function _removeListener(subscription) {
        if (subscription) {
            var subscriptions = _listeners[subscription.channel];
            subscriptions && subscriptions[subscription.id] && (delete subscriptions[subscription.id], 
            _cometd._debug("Removed", subscription.listener ? "listener" : "subscription", subscription));
        }
    }
    function _removeSubscription(subscription) {
        subscription && !subscription.listener && _removeListener(subscription);
    }
    function _clearSubscriptions() {
        for (var channel in _listeners) {
            var subscriptions = _listeners[channel];
            if (subscriptions) for (var i = 0; i < subscriptions.length; ++i) _removeSubscription(subscriptions[i]);
        }
    }
    function _setStatus(newStatus) {
        _status !== newStatus && (_cometd._debug("Status", _status, "->", newStatus), _status = newStatus);
    }
    function _isDisconnected() {
        return "disconnecting" === _status || "disconnected" === _status;
    }
    function _nextMessageId() {
        return ++_messageId;
    }
    function _applyExtension(scope, callback, name, message, outgoing) {
        try {
            return callback.call(scope, message);
        } catch (x) {
            _cometd._debug("Exception during execution of extension", name, x);
            var exceptionCallback = _cometd.onExtensionException;
            if (_isFunction(exceptionCallback)) {
                _cometd._debug("Invoking extension exception callback", name, x);
                try {
                    exceptionCallback.call(_cometd, x, name, outgoing, message);
                } catch (xx) {
                    _cometd._info("Exception during execution of exception callback in extension", name, xx);
                }
            }
            return message;
        }
    }
    function _applyIncomingExtensions(message) {
        for (var i = 0; i < _extensions.length && (void 0 !== message && null !== message); ++i) {
            var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i, extension = _extensions[index], callback = extension.extension.incoming;
            if (_isFunction(callback)) {
                var result = _applyExtension(extension.extension, callback, extension.name, message, !1);
                message = void 0 === result ? message : result;
            }
        }
        return message;
    }
    function _applyOutgoingExtensions(message) {
        for (var i = 0; i < _extensions.length && (void 0 !== message && null !== message); ++i) {
            var extension = _extensions[i], callback = extension.extension.outgoing;
            if (_isFunction(callback)) {
                var result = _applyExtension(extension.extension, callback, extension.name, message, !0);
                message = void 0 === result ? message : result;
            }
        }
        return message;
    }
    function _notify(channel, message) {
        var subscriptions = _listeners[channel];
        if (subscriptions && subscriptions.length > 0) for (var i = 0; i < subscriptions.length; ++i) {
            var subscription = subscriptions[i];
            if (subscription) try {
                subscription.callback.call(subscription.scope, message);
            } catch (x) {
                _cometd._debug("Exception during notification", subscription, message, x);
                var listenerCallback = _cometd.onListenerException;
                if (_isFunction(listenerCallback)) {
                    _cometd._debug("Invoking listener exception callback", subscription, x);
                    try {
                        listenerCallback.call(_cometd, x, subscription, subscription.listener, message);
                    } catch (xx) {
                        _cometd._info("Exception during execution of listener callback", subscription, xx);
                    }
                }
            }
        }
    }
    function _notifyListeners(channel, message) {
        _notify(channel, message);
        for (var channelParts = channel.split("/"), last = channelParts.length - 1, i = last; i > 0; --i) {
            var channelPart = channelParts.slice(0, i).join("/") + "/*";
            i === last && _notify(channelPart, message), channelPart += "*", _notify(channelPart, message);
        }
    }
    function _cancelDelayedSend() {
        null !== _scheduledSend && org.cometd.Utils.clearTimeout(_scheduledSend), _scheduledSend = null;
    }
    function _delayedSend(operation) {
        _cancelDelayedSend();
        var delay = _advice.interval + _backoff;
        _cometd._debug("Function scheduled in", delay, "ms, interval =", _advice.interval, "backoff =", _backoff, operation), 
        _scheduledSend = org.cometd.Utils.setTimeout(_cometd, operation, delay);
    }
    function _send(sync, messages, longpoll, extraPath) {
        for (var i = 0; i < messages.length; ++i) {
            var message = messages[i], messageId = "" + _nextMessageId();
            message.id = messageId, _clientId && (message.clientId = _clientId);
            var callback = void 0;
            _isFunction(message._callback) && (callback = message._callback, delete message._callback), 
            message = _applyOutgoingExtensions(message), void 0 !== message && null !== message ? (message.id = messageId, 
            messages[i] = message, callback && (_callbacks[messageId] = callback)) : messages.splice(i--, 1);
        }
        if (0 !== messages.length) {
            var url = _cometd.getURL();
            _config.appendMessageTypeToURL && (url.match(/\/$/) || (url += "/"), extraPath && (url += extraPath));
            var envelope = {
                url: url,
                sync: sync,
                messages: messages,
                onSuccess: function(rcvdMessages) {
                    try {
                        _handleMessages.call(_cometd, rcvdMessages);
                    } catch (x) {
                        _cometd._debug("Exception during handling of messages", x);
                    }
                },
                onFailure: function(conduit, messages, failure) {
                    try {
                        var transport = _cometd.getTransport();
                        failure.connectionType = transport ? transport.getType() : "unknown", _handleFailure.call(_cometd, conduit, messages, failure);
                    } catch (x) {
                        _cometd._debug("Exception during handling of failure", x);
                    }
                }
            };
            _cometd._debug("Send", envelope), _transport.send(envelope, longpoll);
        }
    }
    function _queueSend(message) {
        _batch > 0 || _internalBatch === !0 ? _messageQueue.push(message) : _send(!1, [ message ], !1);
    }
    function _resetBackoff() {
        _backoff = 0;
    }
    function _increaseBackoff() {
        _backoff < _config.maxBackoff && (_backoff += _config.backoffIncrement);
    }
    function _startBatch() {
        ++_batch;
    }
    function _flushBatch() {
        var messages = _messageQueue;
        _messageQueue = [], messages.length > 0 && _send(!1, messages, !1);
    }
    function _endBatch() {
        if (--_batch, 0 > _batch) throw "Calls to startBatch() and endBatch() are not paired";
        0 !== _batch || _isDisconnected() || _internalBatch || _flushBatch();
    }
    function _connect() {
        if (!_isDisconnected()) {
            var message = {
                channel: "/meta/connect",
                connectionType: _transport.getType()
            };
            _connected || (message.advice = {
                timeout: 0
            }), _setStatus("connecting"), _cometd._debug("Connect sent", message), _send(!1, [ message ], !0, "connect"), 
            _setStatus("connected");
        }
    }
    function _delayedConnect() {
        _setStatus("connecting"), _delayedSend(function() {
            _connect();
        });
    }
    function _updateAdvice(newAdvice) {
        newAdvice && (_advice = _cometd._mixin(!1, {}, _config.advice, newAdvice), _cometd._debug("New advice", _advice));
    }
    function _disconnect(abort) {
        if (_cancelDelayedSend(), abort && _transport && _transport.abort(), _clientId = null, 
        _setStatus("disconnected"), _batch = 0, _resetBackoff(), _transport = null, _messageQueue.length > 0) {
            var messages = _messageQueue;
            _messageQueue = [], _handleFailure.call(_cometd, void 0, messages, {
                reason: "Disconnected"
            });
        }
    }
    function _notifyTransportFailure(oldTransport, newTransport, failure) {
        var callback = _cometd.onTransportFailure;
        if (_isFunction(callback)) {
            _cometd._debug("Invoking transport failure callback", oldTransport, newTransport, failure);
            try {
                callback.call(_cometd, oldTransport, newTransport, failure);
            } catch (x) {
                _cometd._info("Exception during execution of transport failure callback", x);
            }
        }
    }
    function _handshake(handshakeProps, handshakeCallback) {
        _isFunction(handshakeProps) && (handshakeCallback = handshakeProps, handshakeProps = void 0), 
        _clientId = null, _clearSubscriptions(), _isDisconnected() ? (_transports.reset(), 
        _updateAdvice(_config.advice)) : _updateAdvice(_cometd._mixin(!1, _advice, {
            reconnect: "retry"
        })), _batch = 0, _internalBatch = !0, _handshakeProps = handshakeProps, _handshakeCallback = handshakeCallback;
        var version = "1.0", url = _cometd.getURL(), transportTypes = _transports.findTransportTypes(version, _crossDomain, url), bayeuxMessage = {
            version: version,
            minimumVersion: version,
            channel: "/meta/handshake",
            supportedConnectionTypes: transportTypes,
            _callback: handshakeCallback,
            advice: {
                timeout: _advice.timeout,
                interval: _advice.interval
            }
        }, message = _cometd._mixin(!1, {}, _handshakeProps, bayeuxMessage);
        if (!_transport && (_transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url), 
        !_transport)) {
            var failure = "Could not find initial transport among: " + _transports.getTransportTypes();
            throw _cometd._warn(failure), failure;
        }
        _cometd._debug("Initial transport is", _transport.getType()), _setStatus("handshaking"), 
        _cometd._debug("Handshake sent", message), _send(!1, [ message ], !1, "handshake");
    }
    function _delayedHandshake() {
        _setStatus("handshaking"), _internalBatch = !0, _delayedSend(function() {
            _handshake(_handshakeProps, _handshakeCallback);
        });
    }
    function _handleCallback(message) {
        var callback = _callbacks[message.id];
        _isFunction(callback) && (delete _callbacks[message.id], callback.call(_cometd, message));
    }
    function _failHandshake(message) {
        _handleCallback(message), _notifyListeners("/meta/handshake", message), _notifyListeners("/meta/unsuccessful", message);
        var retry = !_isDisconnected() && "none" !== _advice.reconnect;
        retry ? (_increaseBackoff(), _delayedHandshake()) : _disconnect(!1);
    }
    function _handshakeResponse(message) {
        if (message.successful) {
            _clientId = message.clientId;
            var url = _cometd.getURL(), newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, _crossDomain, url);
            if (null === newTransport) {
                var failure = "Could not negotiate transport with server; client=[" + _transports.findTransportTypes(message.version, _crossDomain, url) + "], server=[" + message.supportedConnectionTypes + "]", oldTransport = _cometd.getTransport();
                return _notifyTransportFailure(oldTransport.getType(), null, {
                    reason: failure,
                    connectionType: oldTransport.getType(),
                    transport: oldTransport
                }), _cometd._warn(failure), void _disconnect(!0);
            }
            _transport !== newTransport && (_cometd._debug("Transport", _transport.getType(), "->", newTransport.getType()), 
            _transport = newTransport), _internalBatch = !1, _flushBatch(), message.reestablish = _reestablish, 
            _reestablish = !0, _handleCallback(message), _notifyListeners("/meta/handshake", message);
            var action = _isDisconnected() ? "none" : _advice.reconnect;
            switch (action) {
              case "retry":
                _resetBackoff(), _delayedConnect();
                break;

              case "none":
                _disconnect(!1);
                break;

              default:
                throw "Unrecognized advice action " + action;
            }
        } else _failHandshake(message);
    }
    function _handshakeFailure(message) {
        var version = "1.0", url = _cometd.getURL(), oldTransport = _cometd.getTransport(), transportTypes = _transports.findTransportTypes(version, _crossDomain, url), newTransport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
        newTransport ? (_cometd._debug("Transport", oldTransport.getType(), "->", newTransport.getType()), 
        _notifyTransportFailure(oldTransport.getType(), newTransport.getType(), message.failure), 
        _failHandshake(message), _transport = newTransport) : (_notifyTransportFailure(oldTransport.getType(), null, message.failure), 
        _cometd._warn("Could not negotiate transport; client=[" + transportTypes + "]"), 
        _disconnect(!0), _failHandshake(message));
    }
    function _failConnect(message) {
        _notifyListeners("/meta/connect", message), _notifyListeners("/meta/unsuccessful", message);
        var action = _isDisconnected() ? "none" : _advice.reconnect;
        switch (action) {
          case "retry":
            _delayedConnect(), _increaseBackoff();
            break;

          case "handshake":
            _transports.reset(), _resetBackoff(), _delayedHandshake();
            break;

          case "none":
            _disconnect(!1);
            break;

          default:
            throw "Unrecognized advice action" + action;
        }
    }
    function _connectResponse(message) {
        if (_connected = message.successful) {
            _notifyListeners("/meta/connect", message);
            var action = _isDisconnected() ? "none" : _advice.reconnect;
            switch (action) {
              case "retry":
                _resetBackoff(), _delayedConnect();
                break;

              case "none":
                _disconnect(!1);
                break;

              default:
                throw "Unrecognized advice action " + action;
            }
        } else _failConnect(message);
    }
    function _connectFailure(message) {
        _connected = !1, _failConnect(message);
    }
    function _failDisconnect(message) {
        _disconnect(!0), _handleCallback(message), _notifyListeners("/meta/disconnect", message), 
        _notifyListeners("/meta/unsuccessful", message);
    }
    function _disconnectResponse(message) {
        message.successful ? (_disconnect(!1), _handleCallback(message), _notifyListeners("/meta/disconnect", message)) : _failDisconnect(message);
    }
    function _disconnectFailure(message) {
        _failDisconnect(message);
    }
    function _failSubscribe(message) {
        var subscriptions = _listeners[message.subscription];
        if (subscriptions) for (var i = subscriptions.length - 1; i >= 0; --i) {
            var subscription = subscriptions[i];
            if (subscription && !subscription.listener) {
                delete subscriptions[i], _cometd._debug("Removed failed subscription", subscription);
                break;
            }
        }
        _handleCallback(message), _notifyListeners("/meta/subscribe", message), _notifyListeners("/meta/unsuccessful", message);
    }
    function _subscribeResponse(message) {
        message.successful ? (_handleCallback(message), _notifyListeners("/meta/subscribe", message)) : _failSubscribe(message);
    }
    function _subscribeFailure(message) {
        _failSubscribe(message);
    }
    function _failUnsubscribe(message) {
        _handleCallback(message), _notifyListeners("/meta/unsubscribe", message), _notifyListeners("/meta/unsuccessful", message);
    }
    function _unsubscribeResponse(message) {
        message.successful ? (_handleCallback(message), _notifyListeners("/meta/unsubscribe", message)) : _failUnsubscribe(message);
    }
    function _unsubscribeFailure(message) {
        _failUnsubscribe(message);
    }
    function _failMessage(message) {
        _handleCallback(message), _notifyListeners("/meta/publish", message), _notifyListeners("/meta/unsuccessful", message);
    }
    function _messageResponse(message) {
        void 0 === message.successful ? void 0 !== message.data ? _notifyListeners(message.channel, message) : _cometd._warn("Unknown Bayeux Message", message) : message.successful ? (_handleCallback(message), 
        _notifyListeners("/meta/publish", message)) : _failMessage(message);
    }
    function _messageFailure(failure) {
        _failMessage(failure);
    }
    function _receive(message) {
        if (message = _applyIncomingExtensions(message), void 0 !== message && null !== message) {
            _updateAdvice(message.advice);
            var channel = message.channel;
            switch (channel) {
              case "/meta/handshake":
                _handshakeResponse(message);
                break;

              case "/meta/connect":
                _connectResponse(message);
                break;

              case "/meta/disconnect":
                _disconnectResponse(message);
                break;

              case "/meta/subscribe":
                _subscribeResponse(message);
                break;

              case "/meta/unsubscribe":
                _unsubscribeResponse(message);
                break;

              default:
                _messageResponse(message);
            }
        }
    }
    function _hasSubscriptions(channel) {
        var subscriptions = _listeners[channel];
        if (subscriptions) for (var i = 0; i < subscriptions.length; ++i) if (subscriptions[i]) return !0;
        return !1;
    }
    function _resolveScopedCallback(scope, callback) {
        var delegate = {
            scope: scope,
            method: callback
        };
        if (_isFunction(scope)) delegate.scope = void 0, delegate.method = scope; else if (_isString(callback)) {
            if (!scope) throw "Invalid scope " + scope;
            if (delegate.method = scope[callback], !_isFunction(delegate.method)) throw "Invalid callback " + callback + " for scope " + scope;
        } else if (!_isFunction(callback)) throw "Invalid callback " + callback;
        return delegate;
    }
    function _addListener(channel, scope, callback, isListener) {
        var delegate = _resolveScopedCallback(scope, callback);
        _cometd._debug("Adding", isListener ? "listener" : "subscription", "on", channel, "with scope", delegate.scope, "and callback", delegate.method);
        var subscription = {
            channel: channel,
            scope: delegate.scope,
            callback: delegate.method,
            listener: isListener
        }, subscriptions = _listeners[channel];
        return subscriptions || (subscriptions = [], _listeners[channel] = subscriptions), 
        subscription.id = subscriptions.push(subscription) - 1, _cometd._debug("Added", isListener ? "listener" : "subscription", subscription), 
        subscription[0] = channel, subscription[1] = subscription.id, subscription;
    }
    var _transport, _handshakeProps, _handshakeCallback, _cometd = this, _name = name || "default", _crossDomain = !1, _transports = new org.cometd.TransportRegistry(), _status = "disconnected", _messageId = 0, _clientId = null, _batch = 0, _messageQueue = [], _internalBatch = !1, _listeners = {}, _backoff = 0, _scheduledSend = null, _extensions = [], _advice = {}, _callbacks = {}, _reestablish = !1, _connected = !1, _config = {
        protocol: null,
        stickyReconnect: !0,
        connectTimeout: 0,
        maxConnections: 2,
        backoffIncrement: 1e3,
        maxBackoff: 6e4,
        logLevel: "info",
        reverseIncomingExtensions: !0,
        maxNetworkDelay: 1e4,
        requestHeaders: {},
        appendMessageTypeToURL: !0,
        autoBatch: !1,
        advice: {
            timeout: 6e4,
            interval: 0,
            reconnect: "retry"
        }
    };
    this._mixin = function(deep, target) {
        for (var result = target || {}, i = 2; i < arguments.length; ++i) {
            var object = arguments[i];
            if (void 0 !== object && null !== object) for (var propName in object) {
                var prop = _fieldValue(object, propName), targ = _fieldValue(result, propName);
                if (prop !== target && void 0 !== prop) if (deep && "object" == typeof prop && null !== prop) if (prop instanceof Array) result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop); else {
                    var source = "object" != typeof targ || targ instanceof Array ? {} : targ;
                    result[propName] = this._mixin(deep, source, prop);
                } else result[propName] = prop;
            }
        }
        return result;
    }, this._warn = function() {
        _log("warn", arguments);
    }, this._info = function() {
        "warn" !== _config.logLevel && _log("info", arguments);
    }, this._debug = function() {
        "debug" === _config.logLevel && _log("debug", arguments);
    }, this._isCrossDomain = function(hostAndPort) {
        return hostAndPort && hostAndPort !== window.location.host;
    };
    var _handleMessages, _handleFailure;
    this.send = _queueSend, this.receive = _receive, _handleMessages = function(rcvdMessages) {
        _cometd._debug("Received", rcvdMessages);
        for (var i = 0; i < rcvdMessages.length; ++i) {
            var message = rcvdMessages[i];
            _receive(message);
        }
    }, _handleFailure = function(conduit, messages, failure) {
        _cometd._debug("handleFailure", conduit, messages, failure), failure.transport = conduit;
        for (var i = 0; i < messages.length; ++i) {
            var message = messages[i], failureMessage = {
                id: message.id,
                successful: !1,
                channel: message.channel,
                failure: failure
            };
            switch (failure.message = message, message.channel) {
              case "/meta/handshake":
                _handshakeFailure(failureMessage);
                break;

              case "/meta/connect":
                _connectFailure(failureMessage);
                break;

              case "/meta/disconnect":
                _disconnectFailure(failureMessage);
                break;

              case "/meta/subscribe":
                failureMessage.subscription = message.subscription, _subscribeFailure(failureMessage);
                break;

              case "/meta/unsubscribe":
                failureMessage.subscription = message.subscription, _unsubscribeFailure(failureMessage);
                break;

              default:
                _messageFailure(failureMessage);
            }
        }
    }, this.registerTransport = function(type, transport, index) {
        var result = _transports.add(type, transport, index);
        return result && (this._debug("Registered transport", type), _isFunction(transport.registered) && transport.registered(type, this)), 
        result;
    }, this.getTransportTypes = function() {
        return _transports.getTransportTypes();
    }, this.unregisterTransport = function(type) {
        var transport = _transports.remove(type);
        return null !== transport && (this._debug("Unregistered transport", type), _isFunction(transport.unregistered) && transport.unregistered()), 
        transport;
    }, this.unregisterTransports = function() {
        _transports.clear();
    }, this.findTransport = function(name) {
        return _transports.find(name);
    }, this.configure = function(configuration) {
        _configure.call(this, configuration);
    }, this.init = function(configuration, handshakeProps) {
        this.configure(configuration), this.handshake(handshakeProps);
    }, this.handshake = function(handshakeProps, handshakeCallback) {
        _setStatus("disconnected"), _reestablish = !1, _handshake(handshakeProps, handshakeCallback);
    }, this.disconnect = function(sync, disconnectProps, disconnectCallback) {
        if (!_isDisconnected()) {
            "boolean" != typeof sync && (disconnectCallback = disconnectProps, disconnectProps = sync, 
            sync = !1), _isFunction(disconnectProps) && (disconnectCallback = disconnectProps, 
            disconnectProps = void 0);
            var bayeuxMessage = {
                channel: "/meta/disconnect",
                _callback: disconnectCallback
            }, message = this._mixin(!1, {}, disconnectProps, bayeuxMessage);
            _setStatus("disconnecting"), _send(sync === !0, [ message ], !1, "disconnect");
        }
    }, this.startBatch = function() {
        _startBatch();
    }, this.endBatch = function() {
        _endBatch();
    }, this.batch = function(scope, callback) {
        var delegate = _resolveScopedCallback(scope, callback);
        this.startBatch();
        try {
            delegate.method.call(delegate.scope), this.endBatch();
        } catch (x) {
            throw this._info("Exception during execution of batch", x), this.endBatch(), x;
        }
    }, this.addListener = function(channel, scope, callback) {
        if (arguments.length < 2) throw "Illegal arguments number: required 2, got " + arguments.length;
        if (!_isString(channel)) throw "Illegal argument type: channel must be a string";
        return _addListener(channel, scope, callback, !0);
    }, this.removeListener = function(subscription) {
        if (!(subscription && subscription.channel && "id" in subscription)) throw "Invalid argument: expected subscription, not " + subscription;
        _removeListener(subscription);
    }, this.clearListeners = function() {
        _listeners = {};
    }, this.subscribe = function(channel, scope, callback, subscribeProps, subscribeCallback) {
        if (arguments.length < 2) throw "Illegal arguments number: required 2, got " + arguments.length;
        if (!_isString(channel)) throw "Illegal argument type: channel must be a string";
        if (_isDisconnected()) throw "Illegal state: already disconnected";
        _isFunction(scope) && (subscribeCallback = subscribeProps, subscribeProps = callback, 
        callback = scope, scope = void 0), _isFunction(subscribeProps) && (subscribeCallback = subscribeProps, 
        subscribeProps = void 0);
        var send = !_hasSubscriptions(channel), subscription = _addListener(channel, scope, callback, !1);
        if (send) {
            var bayeuxMessage = {
                channel: "/meta/subscribe",
                subscription: channel,
                _callback: subscribeCallback
            }, message = this._mixin(!1, {}, subscribeProps, bayeuxMessage);
            _queueSend(message);
        }
        return subscription;
    }, this.unsubscribe = function(subscription, unsubscribeProps, unsubscribeCallback) {
        if (arguments.length < 1) throw "Illegal arguments number: required 1, got " + arguments.length;
        if (_isDisconnected()) throw "Illegal state: already disconnected";
        _isFunction(unsubscribeProps) && (unsubscribeCallback = unsubscribeProps, unsubscribeProps = void 0), 
        this.removeListener(subscription);
        var channel = subscription.channel;
        if (!_hasSubscriptions(channel)) {
            var bayeuxMessage = {
                channel: "/meta/unsubscribe",
                subscription: channel,
                _callback: unsubscribeCallback
            }, message = this._mixin(!1, {}, unsubscribeProps, bayeuxMessage);
            _queueSend(message);
        }
    }, this.resubscribe = function(subscription, subscribeProps) {
        return _removeSubscription(subscription), subscription ? this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps) : void 0;
    }, this.clearSubscriptions = function() {
        _clearSubscriptions();
    }, this.publish = function(channel, content, publishProps, publishCallback) {
        if (arguments.length < 1) throw "Illegal arguments number: required 1, got " + arguments.length;
        if (!_isString(channel)) throw "Illegal argument type: channel must be a string";
        if (/^\/meta\//.test(channel)) throw "Illegal argument: cannot publish to meta channels";
        if (_isDisconnected()) throw "Illegal state: already disconnected";
        _isFunction(content) ? (publishCallback = content, content = publishProps = {}) : _isFunction(publishProps) && (publishCallback = publishProps, 
        publishProps = {});
        var bayeuxMessage = {
            channel: channel,
            data: content,
            _callback: publishCallback
        }, message = this._mixin(!1, {}, publishProps, bayeuxMessage);
        _queueSend(message);
    }, this.getStatus = function() {
        return _status;
    }, this.isDisconnected = _isDisconnected, this.setBackoffIncrement = function(period) {
        _config.backoffIncrement = period;
    }, this.getBackoffIncrement = function() {
        return _config.backoffIncrement;
    }, this.getBackoffPeriod = function() {
        return _backoff;
    }, this.setLogLevel = function(level) {
        _config.logLevel = level;
    }, this.registerExtension = function(name, extension) {
        if (arguments.length < 2) throw "Illegal arguments number: required 2, got " + arguments.length;
        if (!_isString(name)) throw "Illegal argument type: extension name must be a string";
        for (var existing = !1, i = 0; i < _extensions.length; ++i) {
            var existingExtension = _extensions[i];
            if (existingExtension.name === name) {
                existing = !0;
                break;
            }
        }
        return existing ? (this._info("Could not register extension with name", name, "since another extension with the same name already exists"), 
        !1) : (_extensions.push({
            name: name,
            extension: extension
        }), this._debug("Registered extension", name), _isFunction(extension.registered) && extension.registered(name, this), 
        !0);
    }, this.unregisterExtension = function(name) {
        if (!_isString(name)) throw "Illegal argument type: extension name must be a string";
        for (var unregistered = !1, i = 0; i < _extensions.length; ++i) {
            var extension = _extensions[i];
            if (extension.name === name) {
                _extensions.splice(i, 1), unregistered = !0, this._debug("Unregistered extension", name);
                var ext = extension.extension;
                _isFunction(ext.unregistered) && ext.unregistered();
                break;
            }
        }
        return unregistered;
    }, this.getExtension = function(name) {
        for (var i = 0; i < _extensions.length; ++i) {
            var extension = _extensions[i];
            if (extension.name === name) return extension.extension;
        }
        return null;
    }, this.getName = function() {
        return _name;
    }, this.getClientId = function() {
        return _clientId;
    }, this.getURL = function() {
        if (_transport && "object" == typeof _config.urls) {
            var url = _config.urls[_transport.getType()];
            if (url) return url;
        }
        return _config.url;
    }, this.getTransport = function() {
        return _transport;
    }, this.getConfiguration = function() {
        return this._mixin(!0, {}, _config);
    }, this.getAdvice = function() {
        return this._mixin(!0, {}, _advice);
    }, org.cometd.WebSocket = window.WebSocket, org.cometd.WebSocket || (org.cometd.WebSocket = window.MozWebSocket);
}, "function" == typeof define && define.amd && define(function() {
    return org.cometd;
}), function() {
    function bind($, org_cometd) {
        function _setHeaders(xhr, headers) {
            if (headers) for (var headerName in headers) "content-type" !== headerName.toLowerCase() && xhr.setRequestHeader(headerName, headers[headerName]);
        }
        function LongPollingTransport() {
            var _super = new org_cometd.LongPollingTransport(), that = org_cometd.Transport.derive(_super);
            return that.xhrSend = function(packet) {
                return $.ajax({
                    url: packet.url,
                    async: packet.sync !== !0,
                    type: "POST",
                    contentType: "application/json;charset=UTF-8",
                    data: packet.body,
                    beforeSend: function(xhr) {
                        return xhr.withCredentials = !0, _setHeaders(xhr, packet.headers), !0;
                    },
                    success: packet.onSuccess,
                    error: function(xhr, reason, exception) {
                        packet.onError(reason, exception);
                    }
                });
            }, that;
        }
        function CallbackPollingTransport() {
            var _super = new org_cometd.CallbackPollingTransport(), that = org_cometd.Transport.derive(_super);
            return that.jsonpSend = function(packet) {
                $.ajax({
                    url: packet.url,
                    async: packet.sync !== !0,
                    type: "GET",
                    dataType: "jsonp",
                    jsonp: "jsonp",
                    data: {
                        message: packet.body
                    },
                    beforeSend: function(xhr) {
                        return _setHeaders(xhr, packet.headers), !0;
                    },
                    success: packet.onSuccess,
                    error: function(xhr, reason, exception) {
                        packet.onError(reason, exception);
                    }
                });
            }, that;
        }
        return org_cometd.JSON.toJSON = JSON.stringify, org_cometd.JSON.fromJSON = JSON.parse, 
        $.Cometd = function(name) {
            var cometd = new org_cometd.Cometd(name);
            return org_cometd.WebSocket && cometd.registerTransport("websocket", new org_cometd.WebSocketTransport()), 
            cometd.registerTransport("long-polling", new LongPollingTransport()), cometd.registerTransport("callback-polling", new CallbackPollingTransport()), 
            cometd;
        }, $.cometd = new $.Cometd(), $.cometd;
    }
    "function" == typeof define && define.amd ? define([ "jquery", "org/cometd" ], bind) : bind(jQuery, org.cometd);
}();
//# sourceMappingURL=vendor.js.map